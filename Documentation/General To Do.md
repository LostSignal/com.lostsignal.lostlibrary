

### Bugs
---------------------
* Make sure TextObjectEditor sets it to dirty when it's suppose to
* SpriteAtlasLoadingManger custom editor has been broken

### Current To Do
---------------------

* **Ask Unity if they ever considered making a Debug.Log(char[]) so we can make zero alloc debug statements?????

* Need PhysicsUtil class which has a bunch of Collider[] buffers that you can use when doing NonAlloc calls

* Managers need to print warnings if invoking delegates that want to be notified when the manager is ready takes too long
  * Maybe the Manger class uses AwakeManager under the hood to make sure they are spread out over multiple frames
  ```csharp
  private void Awake()
  {
      PlayerManager.Ready(PlayerManagerReady);
      
      void PlayerManagerReady()
      {
          AwakeManager.Run(Initialize);
      }
      
      bool Initialize()
      {
         // Do work;
         return true;
      }
  }
  
  ```
  * Does the above code cause any GC????

  
* Create Attributes
  * LostEditorEvents.OnEnterPlayMode()
  * LostEditorEvents.OnExitPlayMode()
  * LostEditorEvents.OnBuildInitiated()  // Can only do BuildPlayerContent here, not allowed in OnPreprocessBuild
  * LostEditorEvents.OnPreproccessBuild(BuildReport buildReport)
  * LostEditorEvents.OnProcessScene(Scene scene, BuildReport report)
  * LostEditorEvents.OnPostprocessBuild(BuildReport buildReport)
  * LostEditorEvents.OnPostGenerateGradleAndroidProject(string gradlePath)
  * LostEditorEvents.OnDomainReload()
  * Application.isBatchMode
  * Make better system for centralizing UnityEdtior events
    * Make them attributs you put on static functions
    * Use AppConfigSettings as template for the types of attributes to make
    * Also add things like OnPreProcessAsset, Generate solution file, etc
		
* Add AwakeManager?
  * Takes callbacks (with descriptions) and only updates callbacks till MaxMillsecondsPerFrame is reached
  * Prints Warnings (with description) if any one callback exceeds MaxMillsecondsPerFrame
    * This is turned off for release builds, but can be turned on with Remote Inspector

* LevelManager can manipulates the AwakeManager
  * MaxMillsecondsPerFrame (in milliseconds)
    * When doing a level load, it's higher than doing a hard load
  * LevelManager also does not fade up till AwakeManger.IsBusy == false	

	
* Add UpdateManager
  * Replaces CoroutineRunner
  * UpdateManager/BusyManager or LevelManager needs an event for initializing objects on scene load that is not awake/start and will
    initialize over multiple frames.

* Remove UnityTask whereever possible (At least in PlayFab code in favor of async)


	
* Boot Config (Startup)  Bootloader????
  * Needs Progress UI
    * Get Current Release
    * Download/Load Bootloader Prefab/Scene
  * Prefab
  * Bootloader needs DialogManager and XRManager?
  
* Rename RuntimeAppConfig to RuntimeSettings


* Releases
  * ReleaseLocation (Resources, PlayFabTitleData)
    * Saves release.json to resources OnPlay, or OnBuild (if using Resource location)
  * Releases.SaveCurrentRelease(); // Happens OnEnterPlayMode or OnPreprocessBuild
  * Releases.GetCurrentRelease();  // Called by Bootloader
  * If using PlayFab, how do you call the anonymous function!?!?!?!?
    * Need dev/prod releases url

* BootConfig (Lives In Resources)
  * bool SimulateAppFlowInEditor (Shows UI, Doesn't Skip Getting Current Release from AssetDatabase, 
  * Releases.GetCurrentRelease
  * Managers
    * ManagerLocation (Resource Prefab, Scene Name, Addressable Prefab, Addressable Scene)
    * string prefabResourceName, string sceneName, LazyGameObject prefab, LazyScene scene
 
* Bootloader Script
  * Get Current Release from the ReleaseLocation
  * Show Forece Update (if applicable)
* 
* Load Manager (Resources Prefab, Addressables Prefab, 

* Lost Library Static Use Cleanup (Needs [OnExitPlayMode] attribute)
  * GPSUtil.cs has static variables that need cleanup when exiting playmode
  * Manager.cs
  * Platform.cs (android statics)
  * LostPlayerPrefs.cs (isDirty)
  * Localization.cs (currentLanguage)
  * SingletonUtil.cs
  * XRInteractionHelper.cs (Does RuntimeInitializeOnLoadMethod get called every time?)
  * InputFieldTracker.cs
  * Bootloader.cs (isBootloaderInitialized)
  * RuntimeBuildConfig.cs (instance)
  * PlayFabManager.cs (serializerPlugin???)

* Update DialogManaager to have CanvasScalerSetting scriptable object and 
  use that object for setting up CanvasScalers on Dialogs.
  * Update it to change reference resolution as physical screen size gets bigger

* Make PlayerInfo Manager
  * Events 
    * On PlayerId Changed
    * On PlayerName Changed
  * Use this class instead of PlayFabManager
  * PlayFabManager will set UserId/Name on that manager

* Make sure BootConfig, BuildConfigs, GameServerGenerator and AzureFunctionsGenerator 
  are all autogenerated and registered with EditorBuildSettings
    * EditorBuildSettings.AddConfigObject(Namespace, editorAppConfig, true);

* Make a custom mesh importer that looks for sub meshes that have a name that ends in _collision_mesh
  and adds a CollisionMesh component to it.
  * _collision_box
  * _collision_sphere
  * etc...
  * Also make sure it doesn't have a mesh renderer

* Remove Everything Ably (Going to use new Azure Web Pub/Sub instead)

* Finish AppConfig -> BuildConfig renaming (make sure it just works with older projects)
  * appconfig was renamed to bootconfig, make sure source control (and template files) ignore it
    * add bootconfig and releaseconfig while we're at it
    * Also Add the following to to the ignore files
      * "Assets/AddressableAssetsData/*"

* Add Visual Scripting to Default git, p4 and plastic ignore files
  * **/Assets/Unity.VisualScripting.Generated/*
  * **/Assets/Unity.VisualScripting.Generated
  * **/Assets/Unity.VisualScripting.Generated.meta

* Update Bootloader system to have new BootConfig
  * Should also contain current release info
  * Clean out Release/AppVersion code when figured out
  * Make sure it supports Reboot

* Add com.unity.coding libary as a dependency of lost libary

* Make a SafeAreaManager (will pre-built in safe area's for most popular iPhones)

* LostPlayerPrefs needs a refactor
  * DeviceStorage
    * App Open Count
    * Player Custom Ids
  * PlayerStorage
    * Stats
    * Achievements
  * GameStorage 
    * Flag System
    * Checkpoint info?  Saving and restoring to older version?
    * CreateSnapshot()
    * Rollback() (used by checkpoint system)
  * Add Reset File options for each type
  * Can DeviceStorage be reused for other systems like Analytics/Logging/PerfRecording Data, so we can save all that before sending up to the cloud?

* FlagManager System (how will it work with the Player/Game Storage System?)

* StatManager System?
  * Monsters Killed, etc

* **CLEAN UP HAVEN CODE (remove all of the unity example projects code too)
  * Update XR Dialog Follow Code to:
    * https://forum.unity.com/threads/quaternion-smoothdamp.793533/
    * https://gist.github.com/maxattack/4c7b4de00f5c1b95a33b

* Turn Gameplay/Expereince/Experience.cs into "Level.cs"?
  * Basically a Level should be a scriptable object with a Main scene and chunck scenes.
  * Maybe even have a list of "Startup" scenes that should also be loaded
  * This way when you load the level, we know exactly how much to load
  * The LevelManager should handle all of these
  * Objects should also be able to tell the LevelManager that they are "Busy" doing work and the level manager won't fade up till that work is done.

* **PLAYFAB**
  * Make PlayFab an optional dependency (so wrap all playfab code around USING_PLAYFAB)
  * Look at the WIP Folder for any CloudFunctions related code and move it into Cloud Funtions or delete it
  * Update all PlayFab Managers to use Async instead of UnityTask
  * Try to get PlayFab code (specially the caching) working in an outside C# project

* Make sure all cool Lost UGUI scripts have filters to Lost folder with AddComponentMenu

* Clean up any Behaviour code that I think shouldn't exist anymore (Maybe add ```[AddComponent("")]```)

* Add ScriptableObject Event System?
  * https://github.com/roboryantron/Unite2017
  * Events
    * On PlayerData Loaded
    * On PlayerData Before Save
    * On PlayerData After Save
    * On GameData Loaded
    * On GameData Before Save
    * On GameData After Save
    * On Checkpoint Snapshot
    * On Checkpoint Restore
    * On Player Death
    * On Object Pooled
    * On Level Load Start
    * On Level Load Complete
    * On Player Name Changed
  
  * Make sure Bolt Graphs can listen for these

* New Project Setup Tool
  * [ ] Add .editorconfigd
  * [ ] Add .p4ignore, ignore.conf, .gitignore or something else?
  * [ ] Create Game Server Project Generator
  * [ ] Create Azure Functions Project Generator
  * [ ] Use StyleCop?
    * **How do we even do this?  2020.2+ Only**

* Add Searchable Enum Property Drawer
  * https://github.com/roboryantron/UnityEditorJunkie/blob/master/Assets/SearchableEnum/Code/Editor/SearchableEnumDrawer.cs
  * https://github.com/fishtopher/UnityDrawers

* DissonanceManager should print error if "Microphone Usage Description" is empty on iOS

* LiveSwitchManger should print error if "Camera Usage Description" is empty on iOS

* Local Notifications and Push Notification managers
  * Local Notifications Manager (based on Unity's wrapper)
  * Lost.PlayFab should look for a PushNotifications manager if USING_LOST_PUSH_NOTIFICATIONS is on
  * Register for is ready and send up RegisterForIOSPushNotification/RegisterForAndroidPushNotification

* UnityPurchasingManager needs to have a "Is Enable" settings, and print errors if not properly installed
* Add XRManagerSettings (use this instead of IsXRApp)
* Make Settings for PlayFabAnalyticsProvider
* Is Lost Library Codebase completely static instance free?  Can I safely reboot an app without messing this up?

* What about Pooler system.  Should probably move that to Releases
  * Also, how good am I about using the Pooling system in the app?

* Get 2FA Login working (will require some anonymous functions)
  * Will need to define these in Releases?

* Update Reference Tool to figure out the exact location of the bad reference

* Pooling System needs to use the new Manager System
  * Delete SingletonUtil.cs after the move is complete
  * Need to detect if a pooled object is being destroyed?
  * If it's not being destroyed during app shutdown then print an error (Platform.IsShuttingDown)?
  * Would it make more sense to not put a Pooled component on the object and instead keep a HashSet of Instance Ids?

* **MAKE LAYOUT GROUP DISABLER COMPONENT (MAYBE ALL DIALOGS HAVE THIS AS A REQUIRED COMPONENT?)
  * This scans your dialog for all layout groups and waits x seconds before disabling them after a show

* GameObjectState Component (Move, Scale, Rotate, Tint), make networkable
    * Animator ones should have a flag, disable Animator when finished (defaulted to true)
    * Add Showable exist in the project?
      * Will it use ObjectState component with Show/Hide under the hood?

* Can I make a tool to populating the Game window resolutions?



### AppInfo
-------------
* Have runtime App class that loads the config.json and has useful things like:
  * bool IsFirstTimeRunningApp
  * int NumberOfTimesOpened;
  * int DaysPlayed;
  * string LastOpenVersion;
  * ShowRateMe();  // Makes sure to check PlayerData for "Never Show This Again"
  * ShowWhatsNew(); // Only show's it if FirstTimeRunningApp == false, and FirstTimeRunningThisVersion == true
  * bool IsAppQuiting; // I think I have this logic in Platform, but not 100% sure

### New Project Setup Tool
---------------------------------
* [ ] Add .editorconfig
* [ ] Add .p4ignore, ignore.conf, .gitignore or something else?
* [ ] Create Game Server Project Generator
* [ ] Create Azure Functions Project Generator
* [ ] Use StyleCop?
  * **How do we even do this?  2020.2+ Only


### CachedUrlImage Utility
---------------------------------
* Create a CachedUrlImage class.  Takes a URL, has a loading animation, and
  caches the result for later. It will most likely be used for profile pictures.
* URL To Image Util (Does this actually work?)
  ```
  var url = "http://URL to image...";
  var tex = new Texture2D(4, 4, TextureFormat.DXT1, false);
  var www = new WWW(url);
  www.LoadImageIntoTexure(tex);
  spriteRenderer.sprite = Sprite.Create(tex, new Rect(0, 0, tex.width, tex.height, new Vector2(0.5f, 0.5f), 100.0f);
  ```
* Texture2D.Compress - https://docs.unity3d.com/ScriptReference/Texture2D.Compress.html
* https://docs.unity3d.com/ScriptReference/Texture2D.LoadRawTextureData.html
